function Connect-AZNSVolume
{   <#
    .SYNOPSIS
        The Command will create and attach a new Nimble Volume to the current host.
    
    .DESCRIPTION
        The command will retrieve the credentials and IP Address from the Registry for the Nimble Storage Array, and connect to that array. The command with then 
        create a volume on the array to match the passed parameters, and assign access to that volume to the initiator group name that matches the current hostname. 
        Once the mapping has occured, the command will continue to detect newly detected iSCSI volumes until a volume appears that matches the Target ID of the 
        Volume created. Once the iSCSI volume has been detected, it will be connected to persistently, and then refresh the Microsoft VDS (Virtual Disk Service) 
        until that device because available as a WinDisk. The New Windisk that matches the serial number of the Nimble Storage Volume will then be initialized, 
        placed online, a partition created, and then finally formatted. The return opject of this command is the Windows Volume that has been created. 
    
        Additional parameters and more grainular control are available when using the non-Azurestack versions of the commands, i.e. You can set more features using 
        the New-NSVolume Command however, the steps required to automate the attachment or discovery of these volumes is not as automated.
    
    .PARAMETER name
        This mandatory parameter is the name that will be used by both the Nimble Array to define the volume name, but also as the name to use for the 
        Windows Formatted partition. 
    
    .PARAMETER size
        This mandatory parameter is the size in MegaBytes (MB) of the volume to be created. i.e. to create a 100 GigaByte (GB) volume, select 10240 as the size value.
    
    .PARAMETER description
        This commonly a single sentance to descript the contents of this volume. This is stored on the array and can help a storage administrator determine the usage
        of a specific volume. If no value is set, and autogenerated value with be used.
    .EXAMPLE
        PS C:\Users\TestUser> Connect-AZNSVolume -size 10240 -name Test10
        Successfully connected to array 10.1.240.20
    
        DriveLetter FileSystemLabel FileSystem DriveType HealthStatus OperationalStatus SizeRemaining    Size
        ----------- --------------- ---------- --------- ------------ ----------------- -------------    ----
        R           Test10          NTFS       Fixed     Healthy      OK                      9.93 GB 9.97 GB
    
    .NOTES
        This module command assumes that you have installed it via the Unattended installation script for connecting AzureStack to a Nimble Storage Infrastructure. 
        All functions use the Verb-Nouns contruct, but the Noun is always preceeded by AZNS which stands for AzureStack Nimble Storage. This prevents collisions in 
        customer enviornments Additional information about the function or script.
    .LINK
        Please see the GitHUB repository for updated versions of this command. Always use the UnattendedNimbleInstall to install the command as to make the command
        visible you must also alter the HPENimbleStorage PowerShell Toolkit manifest to include this file.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $True)]
        [string] $name,
        [Parameter(Mandatory = $True)]
        [Nullable[long]] $size,
        [string] $description= "Autogenerated LUN for AzureStack"
        ) 
    process
    {   write-progress -activity "Connect Nimble Storage Volume" -status "retrieving stored credentials" -PercentComplete 0
        # First lets make sure we are connected to the controller
        <#
        $MyLocalIQN=(Get-InitiatorPort | where-object {$_.ConnectionType -like "iSCSI"} ).nodeaddress
        $MyNimUsername=(Get-ItemProperty -Path HKCU:\Software\NimbleStorage\Credentials\DefaultCred).UserName
        $MyNimPassword=(Get-ItemProperty -Path HKCU:\Software\NimbleStorage\Credentials\DefaultCred).Password
        $MyNimIPAddress=(Get-ItemProperty -Path HKCU:\Software\NimbleStorage\Credentials\DefaultCred).IPAddress
        $NimblePasswordObect = ConvertTo-SecureString $MyNimPassword -AsPlainText -force
        $NimbleCredObject = new-object -typename System.Management.Automation.PSCredential -argumentlist $MyNimUsername, $NimblePasswordObect
        $OutputSuppress = Connect-NSGroup -Group $MyNimIPAddress -Credential $NimbleCredObject -IgnoreServerCertificate
        #>
        start-sleep -seconds 1
        write-progress -activity "Connect Nimble Storage Volume" -status "Connecting to Nimble Storage Target" -PercentComplete 10
        $OutputSuppress = Connect-AzNsGroup -UserNWTCredentials $true -IgnoreServerCertificate
        start-sleep -seconds 1
        write-progress -activity "Connect Nimble Storage Volume" -status "Creating and mapping Nimble Volume" -PercentComplete 20
        $OutputSuppress = New-NSVolume -name $name -description $description -size $size
        $NewVolID = (get-nsvolume -name $name).id
        $MyIgroupID = (Get-NSInitiatorGroup -name (hostname)).id
        $OutputSuppress= New-NSAccessControlRecord -initiator_group_id $MyIgroupID -vol_id $NewVolID | format-table vol_name,initiator_group_name
        $NNum=(Get-nSVolume -name $name).serial_number
        $AM=(Get-nSVolume -name $name).target_name
        start-sleep -seconds 1
        write-progress -activity "Connect Nimble Storage Volume" -status "Detecting Nimble Storage Volume Serial and Target IQN" -PercentComplete 30
        $count=40
        write-host "Detecting ISCSI." -NoNewline
        while ( -not (Get-iscsiTarget | where-object {$_.nodeaddress -eq $AM}) ) 
            {   write-progress -activity "Connect Nimble Storage Volume" -status "Refreshing and Detecting hosts new iSCSI Targets" -PercentComplete $count
                Update-IscsiTarget
                write-host "." -NoNewline 
                $count=$count+1
                start-sleep -seconds 10
            }
        $count=65
        $OutputSuppress = Get-iscsiTarget | where-object {$_.nodeaddress -eq $AM} | connect-iscsitarget -IsPersistent $true
        write-host "Detecting Disk." -NoNewline
        while ( -not (get-disk -serialnumber $NNum -ErrorAction SilentlyContinue) )
            {   write-progress -activity "Connect Nimble Storage Volume" -status "Discovering Nimble Volume in Windows Volume Disk Service" -PercentComplete $count
                $count=$count+1
                write-host "." -NoNewline
                $verbose = "rescan" | diskpart
                start-sleep -Seconds 10 # If you shorten this, the script locks up since too many fast refreshes make iscsi crash
            }
        Stop-Service -Name ShellHWDetection
        start-sleep -seconds 1
        write-progress -activity "Connect Nimble Storage Volume" -status "Initializing the Nimble Volume, Online the Nimble Volume" -PercentComplete 90
        $OutputSuppress=get-disk -serialnumber $NNum | Initialize-Disk -passthru | set-disk -IsOffline $false
        start-sleep -seconds 1
        write-progress -activity "Connect Nimble Storage Volume" -status "Creating Windows Partition and Formatting Nimble Volume" -PercentComplete 95
        $OutputSuppress=get-disk -serialnumber $NNum | New-Partition -UseMaximumSize -assigndriveletter 
        $OutputSuppress=get-disk -serialnumber $NNum | get-partition | where{$_.driveletter} | Format-Volume -NewFileSystemLabel $name
        start-service -Name ShellHWDetection
        start-sleep -seconds 1
        write-progress -activity "Connect Nimble Storage Volume" -status "Complete" -PercentComplete 100
        start-sleep -seconds 1
        return (get-disk -serialnumber $NNum | get-partition | where{$_.driveletter} | get-volume)
    }
}

function Test-NSNimbleWindowsToolkitInstalledConfigured{
    <#
    .SYNOPSIS
        detects if the Nimble Windows Toolkit is installed and if the Set-NWTConfiguration has been run successfully.
        If it has, it returns true, otherwise false
    #>
        $NWTRegPath="HKLM:\Software\Nimble Storage\Configuration\GrpMgmtProfileList"
        $RegExists=Get-Item -Path $NWTRegPath -ErrorAction SilentlyContinue
        if ($RegExists)
            {   return $true
            } else 
            {   return $false
            }
    }

function Get-NSNimbleWindowsToolkitCredentials{
        <#
        .SYNOPSIS
            Finds all of the arrays and username combinations that have been connected via Set-NWTConfiguration
        #>
            $NWTRegPath="HKLM:\Software\Nimble Storage\Configuration\GrpMgmtProfileList"
            [System.Collections.ArrayList] $InsideDataSet= @()
            foreach ( $NWTReg in (get-childitem -path $NWTRegPath).name )
            {   $InsidePath = $NWTReg.replace("HKEY_LOCAL_MACHINE","HKLM:")
                $InsideData = Get-ItemProperty -path $InsidePath
                $InsideData.PSObject.Properties.Remove('PSParentPath')
                $InsideData.PSObject.Properties.Remove('PSPath')
                $InsideData.PSObject.Properties.Remove('PSChildName')
                $InsideData.PSObject.Properties.Remove('PSDrive')
                $InsideData.PSObject.Properties.Remove('PSProvider')
                $InsideData.PSObject.Properties.Remove('Password')
                $InsideDataSet.add($InsideData) | out-null
            }
            return $insidedataSet
        }
    
function Get-NSNimbleWindowsToolkitCredentialsPrivate{
        <#
        .SYNOPSIS
            Finds all of the arrays and username combinations that have been connected via Set-NWTConfiguration
        #>
            $NWTRegPath="HKLM:\Software\Nimble Storage\Configuration\GrpMgmtProfileList"
            [System.Collections.ArrayList] $InsideDataSet= @()
            foreach ( $NWTReg in (get-childitem -path $NWTRegPath).name )
            {
                $InsidePath = $NWTReg.replace("HKEY_LOCAL_MACHINE","HKLM:")
                $InsideData = Get-ItemProperty -path $InsidePath
                $NIMPsswd=$InsideData.Password
                $NimPsswdString=""
                foreach($Value in $NIMPsswd)
                    {   $HexVal=[string]::format("{0:x}",$Value)
                        if( $HexVal.length -eq 1 )
                            {   $HexVal="0"+$HexVal
                            }
                        $NimPsswdString+=$HexVal
                    }
                $InsideData.PSObject.Properties.Remove('PSParentPath')
                $InsideData.PSObject.Properties.Remove('PSPath')
                $InsideData.PSObject.Properties.Remove('PSChildName')
                $InsideData.PSObject.Properties.Remove('PSDrive')
                $InsideData.PSObject.Properties.Remove('PSProvider')
                $InsideData.PSObject.Properties.Remove('Password')
                $InsideData | add-member -MemberType NoteProperty -Name "Password" -Value "$NimPsswdString"
                $NewTempCred=New-object -TypeName System.Management.Automation.PSCredential -argumentlist ($insideData.username), ($NimPsswdString | convertto-securestring)
                $CleanedPassword=$NewTempCred.GetNetworkCredential().Password
                $CleanedPassword=$CleanedPassword.substring(0,$CleanedPassword.length-2)
                $InsideData | add-member -MemberType NoteProperty -Name "DecryptedPassword" -Value "$CleanedPassword"
                $InsideDataSet.add($InsideData) | out-null
            }
            return $insidedataSet
        }
       
function Connect-AZNSGroup {
            <#
            .SYNOPSIS
                Connects to a Nimble Storage group.
            .DESCRIPTION
                Connect-NSGroup is an advanced function that provides the initial connection to a Nimble Storage
                array so that other subsequent commands can be run without having to authenticate individually.
                It is recommended to ignore the server certificate validation (-IgnoreServerCertificate param)
                since Nimble uses an untrusted SSL certificate.
            .PARAMETER Group
                The DNS name or IP address of the Nimble group.
            .PARAMETER Credential
                Specifies a user account that has permission to perform this action. Type a user name, such as User01
                or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a
                user name, this function prompts you for a password.
            .PARAMETER IgnoreServerCertificate
                Ignore the server SSL certificate.
            .EXAMPLE
                 Connect-NSGroup -Group nimblegroup.yourdns.local -Credential admin -IgnoreServerCertificate
            
                 *Note: IgnoreServerCertificate parameter is not available with PowerShell Core
            .EXAMPLE
                 Connect-NSGroup -Group 192.168.1.50 -Credential admin -IgnoreServerCertificate
            
                 *Note: IgnoreServerCertificate parameter is not available with PowerShell Core
            .EXAMPLE
                 Connect-NSGroup -Group nimblegroup.yourdns.local -Credential admin -ImportServerCertificate
            .EXAMPLE
                 Connect-NSGroup -Group 192.168.1.50 -Credential admin -ImportServerCertificate
            .INPUTS
                None
            .OUTPUTS
                None
            .NOTES
            
            #>
                [cmdletbinding(DefaultParameterSetName='IgnoreServerCertificate')]
                param   (
                    [Parameter(position=0)]
                    [string]$Group,
            
                    [Parameter(position=1)]
                    $Credential=$null,
                    
                    [Parameter(position=3)]
                    [boolean]$UserNWTCredentials=$null,
                    
                    [Parameter(ParameterSetName='ImportServerCertificate')]
                    [switch]$ImportServerCertificate
                )
            
                DynamicParam {
                        if ($PSEdition -ne 'Core'){ 
            
                             $IgnoreServerCertificateAttribute = New-Object System.Management.Automation.ParameterAttribute
                             $IgnoreServerCertificateAttribute.Mandatory = $false
                             #$IgnoreServerCertificateAttribute.Position = 4
                             $IgnoreServerCertificateAttribute.ParameterSetName = 'IgnoreServerCertificate'
                             $attributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
                             $attributeCollection.Add($IgnoreServerCertificateAttribute)  
                             $IgnoreServerCertificateParam = New-Object System.Management.Automation.RuntimeDefinedParameter('IgnoreServerCertificate', [Switch],$attributeCollection)
                             $paramDictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary
                             $paramDictionary.Add('IgnoreServerCertificate', $IgnoreServerCertificateParam)
                             return $paramDictionary
            
                             }
                        }
            
                Process{
                    if ($UserNWTCredentials)
                        {   $MyTempCredObject=$(Get-NSNimbleWindowsToolkitCredentialsPrivate)
                            $Group=($MyTempCredObject).GroupMgmtIP
                            $MyTempDecryptedPassword=($MyTempCredObject).decryptedpassword 
                            $MyTempPasswordObject= $MyTempDecryptedPassword | convertto-securestring -asplaintext -force
                            $MyTempUserName= ($MyTempCredObject).UserName
                            $Credential=new-object system.management.automation.pscredential ( $MyTempUserName, $MyTempPasswordObject )
                            remove-variable -name MyTempDecryptedPassword
                            remove-variable -name MyTempCredObject
                            Remove-Variable -name MyTempPasswordObject
                            remove-variable -name MyTempUserName
                        } else 
                        {   if ($Credential -is [String]) 
                                {   $Credential = Get-Credential $Credential
                                }
                        }
                    $global:Group=$Group
                    if ($PSBoundParameters.IgnoreServerCertificate) 
                        {   $Global:NimbleStorageIgnoreServerCertificate = $true
                            IgnoreServerCertificate
                        } else 
                        {
                            $Global:NimbleStorageIgnoreServerCertificate = $false
                            $Global:GlobalImportServerCertificate = $ImportServerCertificate
                            ValidateServerCertificate $group
                        }
            
                    Import-LocalizedData -BaseDirectory (Split-Path $PSScriptRoot -parent) -FileName "HPENimblePowerShellToolkit.psd1" -BindingVariable "ModuleData"
                    $PSTKVersion = $ModuleData.moduleversion
                    $Global:NimbleAppName = "HPENimblePowerShellToolkitV" + $PSTKVersion
                    $Global:NimbleStoragePort = 5392
                    $Global:BaseUri = "https://$($global:Group):$($NimbleStoragePort)"
                    try{
                        $Global:NimbleStorageTokenData = Invoke-RestMethod -Uri "$BaseUri/v1/tokens" -Method Post -Body ((@{data = @{username = $Credential.UserName;password = $Credential.GetNetworkCredential().password;app_name = $NimbleAppName}}) | ConvertTo-Json)
                        Write-Host "Successfully connected to array $group `n`n"
                    }
                    catch{
                        Write-error "Failed to connect with array $group `n`n $_.Exception.Message" -ErrorAction Stop
                    }
                    $Global:RestVersion = (Invoke-RestMethod -Uri "$BaseUri/versions").data.name
                    $Global:NimbleStorageSession_token = $NimbleStorageTokenData.data.session_token
                    $Global:NimbleStorageArray = $group
                    $Global:NimbleStorageCommonPSParams=@('Debug','Verbose','ErrorAction','ErrorVariable','InformationAction','InformationVariable','OutBuffer','OutVariable','PipelineVariable','Verbose','WarningAction','WarningVariable','WhatIf','Confim','ItemType')
                }
            }
            